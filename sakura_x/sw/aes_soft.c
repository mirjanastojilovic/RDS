/*
 RDS: FPGA Routing Delay Sensors for Effective Remote Power Analysis Attacks
 Copyright 2023, School of Computer and Communication Sciences, EPFL.

 All rights reserved. Use of this source code is governed by a
 BSD-style license that can be found in the LICENSE.md file. 
 */

#include "stdio.h"
#include "stdlib.h"
#include "string.h"

#include "aes_soft.h"

unsigned char s_box[256] = {0x63 ,0x7C ,0x77 ,0x7B ,0xF2 ,0x6B ,0x6F ,0xC5 ,0x30 ,0x01 ,0x67 ,0x2B ,0xFE ,0xD7 ,0xAB ,0x76,
                            0xCA ,0x82 ,0xC9 ,0x7D ,0xFA ,0x59 ,0x47 ,0xF0 ,0xAD ,0xD4 ,0xA2 ,0xAF ,0x9C ,0xA4 ,0x72 ,0xC0,
                            0xB7 ,0xFD ,0x93 ,0x26 ,0x36 ,0x3F ,0xF7 ,0xCC ,0x34 ,0xA5 ,0xE5 ,0xF1 ,0x71 ,0xD8 ,0x31 ,0x15,
                            0x04 ,0xC7 ,0x23 ,0xC3 ,0x18 ,0x96 ,0x05 ,0x9A ,0x07 ,0x12 ,0x80 ,0xE2 ,0xEB ,0x27 ,0xB2 ,0x75,
                            0x09 ,0x83 ,0x2C ,0x1A ,0x1B ,0x6E ,0x5A ,0xA0 ,0x52 ,0x3B ,0xD6 ,0xB3 ,0x29 ,0xE3 ,0x2F ,0x84,
                            0x53 ,0xD1 ,0x00 ,0xED ,0x20 ,0xFC ,0xB1 ,0x5B ,0x6A ,0xCB ,0xBE ,0x39 ,0x4A ,0x4C ,0x58 ,0xCF,
                            0xD0 ,0xEF ,0xAA ,0xFB ,0x43 ,0x4D ,0x33 ,0x85 ,0x45 ,0xF9 ,0x02 ,0x7F ,0x50 ,0x3C ,0x9F ,0xA8,
                            0x51 ,0xA3 ,0x40 ,0x8F ,0x92 ,0x9D ,0x38 ,0xF5 ,0xBC ,0xB6 ,0xDA ,0x21 ,0x10 ,0xFF ,0xF3 ,0xD2,
                            0xCD ,0x0C ,0x13 ,0xEC ,0x5F ,0x97 ,0x44 ,0x17 ,0xC4 ,0xA7 ,0x7E ,0x3D ,0x64 ,0x5D ,0x19 ,0x73,
                            0x60 ,0x81 ,0x4F ,0xDC ,0x22 ,0x2A ,0x90 ,0x88 ,0x46 ,0xEE ,0xB8 ,0x14 ,0xDE ,0x5E ,0x0B ,0xDB,
                            0xE0 ,0x32 ,0x3A ,0x0A ,0x49 ,0x06 ,0x24 ,0x5C ,0xC2 ,0xD3 ,0xAC ,0x62 ,0x91 ,0x95 ,0xE4 ,0x79,
                            0xE7 ,0xC8 ,0x37 ,0x6D ,0x8D ,0xD5 ,0x4E ,0xA9 ,0x6C ,0x56 ,0xF4 ,0xEA ,0x65 ,0x7A ,0xAE ,0x08,
                            0xBA ,0x78 ,0x25 ,0x2E ,0x1C ,0xA6 ,0xB4 ,0xC6 ,0xE8 ,0xDD ,0x74 ,0x1F ,0x4B ,0xBD ,0x8B ,0x8A,
                            0x70 ,0x3E ,0xB5 ,0x66 ,0x48 ,0x03 ,0xF6 ,0x0E ,0x61 ,0x35 ,0x57 ,0xB9 ,0x86 ,0xC1 ,0x1D ,0x9E,
                            0xE1 ,0xF8 ,0x98 ,0x11 ,0x69 ,0xD9 ,0x8E ,0x94 ,0x9B ,0x1E ,0x87 ,0xE9 ,0xCE ,0x55 ,0x28 ,0xDF,
                            0x8C ,0xA1 ,0x89 ,0x0D ,0xBF ,0xE6 ,0x42 ,0x68 ,0x41 ,0x99 ,0x2D ,0x0F ,0xB0 ,0x54 ,0xBB ,0x16};
/*
Look-up table containing the results of multiplication of all 256 values a byte can have by 2.
The multiplication performed is a modulo 2 multiplication, meaning that we multiply the Galois field corresponding to 
the input byte with the Galois field corresponding to the byte 0x02. After the multiplication, if the result is a Galois 
field with a higher polynomial degree than 7, we subtract (binary, with modulo 2 i.e. XOR) with the polynomial X^8+x^4+x^3+x^1+x^0
so that the result fits in one byte.
*/
unsigned char mul2[256] = {0x00,0x02,0x04,0x06,0x08,0x0A,0x0C,0x0E,0x10,0x12,0x14,0x16,0x18,0x1A,0x1C,0x1E,
                           0x20,0x22,0x24,0x26,0x28,0x2A,0x2C,0x2E,0x30,0x32,0x34,0x36,0x38,0x3A,0x3C,0x3E,
                           0x40,0x42,0x44,0x46,0x48,0x4A,0x4C,0x4E,0x50,0x52,0x54,0x56,0x58,0x5A,0x5C,0x5E,
                           0x60,0x62,0x64,0x66,0x68,0x6A,0x6C,0x6E,0x70,0x72,0x74,0x76,0x78,0x7A,0x7C,0x7E,
                           0x80,0x82,0x84,0x86,0x88,0x8A,0x8C,0x8E,0x90,0x92,0x94,0x96,0x98,0x9A,0x9C,0x9E,
                           0xA0,0xA2,0xA4,0xA6,0xA8,0xAA,0xAC,0xAE,0xB0,0xB2,0xB4,0xB6,0xB8,0xBA,0xBC,0xBE,
                           0xC0,0xC2,0xC4,0xC6,0xC8,0xCA,0xCC,0xCE,0xD0,0xD2,0xD4,0xD6,0xD8,0xDA,0xDC,0xDE,
                           0xE0,0xE2,0xE4,0xE6,0xE8,0xEA,0xEC,0xEE,0xF0,0xF2,0xF4,0xF6,0xF8,0xFA,0xFC,0xFE,
                           0x1B,0x19,0x1F,0x1D,0x13,0x11,0x17,0x15,0x0B,0x09,0x0F,0x0D,0x03,0x01,0x07,0x05,
                           0x3B,0x39,0x3F,0x3D,0x33,0x31,0x37,0x35,0x2B,0x29,0x2F,0x2D,0x23,0x21,0x27,0x25,
                           0x5B,0x59,0x5F,0x5D,0x53,0x51,0x57,0x55,0x4B,0x49,0x4F,0x4D,0x43,0x41,0x47,0x45,
                           0x7B,0x79,0x7F,0x7D,0x73,0x71,0x77,0x75,0x6B,0x69,0x6F,0x6D,0x63,0x61,0x67,0x65,
                           0x9B,0x99,0x9F,0x9D,0x93,0x91,0x97,0x95,0x8B,0x89,0x8F,0x8D,0x83,0x81,0x87,0x85,
                           0xBB,0xB9,0xBF,0xBD,0xB3,0xB1,0xB7,0xB5,0xAB,0xA9,0xAF,0xAD,0xA3,0xA1,0xA7,0xA5,
                           0xDB,0xD9,0xDF,0xDD,0xD3,0xD1,0xD7,0xD5,0xCB,0xC9,0xCF,0xCD,0xC3,0xC1,0xC7,0xC5,
                           0xFB,0xF9,0xFF,0xFD,0xF3,0xF1,0xF7,0xF5,0xEB,0xE9,0xEF,0xED,0xE3,0xE1,0xE7,0xE5};

/*
Look-up table containing the results of multiplication of all 256 values a byte can have by 3.
The multiplication performed is a modulo 2 multiplication, meaning that we multiply the Galois field corresponding to 
the input byte with the Galois field corresponding to the byte 0x03. After the multiplication, if the result is a Galois 
field with a higher polynomial degree than 7, we subtract (binary, with modulo 2 i.e. XOR) with the polynomial X^8+x^4+x^3+x^1+x^0
so that the result fits in one byte.
*/
unsigned char mul3[256] = {0x00,0x03,0x06,0x05,0x0C,0x0F,0x0A,0x09,0x18,0x1B,0x1E,0x1D,0x14,0x17,0x12,0x11,
                           0x30,0x33,0x36,0x35,0x3C,0x3F,0x3A,0x39,0x28,0x2B,0x2E,0x2D,0x24,0x27,0x22,0x21,
                           0x60,0x63,0x66,0x65,0x6C,0x6F,0x6A,0x69,0x78,0x7B,0x7E,0x7D,0x74,0x77,0x72,0x71,
                           0x50,0x53,0x56,0x55,0x5C,0x5F,0x5A,0x59,0x48,0x4B,0x4E,0x4D,0x44,0x47,0x42,0x41,
                           0xC0,0xC3,0xC6,0xC5,0xCC,0xCF,0xCA,0xC9,0xD8,0xDB,0xDE,0xDD,0xD4,0xD7,0xD2,0xD1,
                           0xF0,0xF3,0xF6,0xF5,0xFC,0xFF,0xFA,0xF9,0xE8,0xEB,0xEE,0xED,0xE4,0xE7,0xE2,0xE1,
                           0xA0,0xA3,0xA6,0xA5,0xAC,0xAF,0xAA,0xA9,0xB8,0xBB,0xBE,0xBD,0xB4,0xB7,0xB2,0xB1,
                           0x90,0x93,0x96,0x95,0x9C,0x9F,0x9A,0x99,0x88,0x8B,0x8E,0x8D,0x84,0x87,0x82,0x81,
                           0x9B,0x98,0x9D,0x9E,0x97,0x94,0x91,0x92,0x83,0x80,0x85,0x86,0x8F,0x8C,0x89,0x8A,
                           0xAB,0xA8,0xAD,0xAE,0xA7,0xA4,0xA1,0xA2,0xB3,0xB0,0xB5,0xB6,0xBF,0xBC,0xB9,0xBA,
                           0xFB,0xF8,0xFD,0xFE,0xF7,0xF4,0xF1,0xF2,0xE3,0xE0,0xE5,0xE6,0xEF,0xEC,0xE9,0xEA,
                           0xCB,0xC8,0xCD,0xCE,0xC7,0xC4,0xC1,0xC2,0xD3,0xD0,0xD5,0xD6,0xDF,0xDC,0xD9,0xDA,
                           0x5B,0x58,0x5D,0x5E,0x57,0x54,0x51,0x52,0x43,0x40,0x45,0x46,0x4F,0x4C,0x49,0x4A,
                           0x6B,0x68,0x6D,0x6E,0x67,0x64,0x61,0x62,0x73,0x70,0x75,0x76,0x7F,0x7C,0x79,0x7A,
                           0x3B,0x38,0x3D,0x3E,0x37,0x34,0x31,0x32,0x23,0x20,0x25,0x26,0x2F,0x2C,0x29,0x2A,
                           0x0B,0x08,0x0D,0x0E,0x07,0x04,0x01,0x02,0x13,0x10,0x15,0x16,0x1F,0x1C,0x19,0x1A};

unsigned char rcon[256] = {0x8D,0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x1B,0x36,0x6C,0xD8,0xAB,0x4D,0x9A, 
                           0x2F,0x5E,0xBC,0x63,0xC6,0x97,0x35,0x6A,0xD4,0xB3,0x7D,0xFA,0xEF,0xC5,0x91,0x39, 
                           0x72,0xE4,0xD3,0xBD,0x61,0xC2,0x9F,0x25,0x4A,0x94,0x33,0x66,0xCC,0x83,0x1D,0x3A, 
                           0x74,0xE8,0xCB,0x8D,0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x1B,0x36,0x6C,0xD8, 
                           0xAB,0x4D,0x9A,0x2F,0x5E,0xBC,0x63,0xC6,0x97,0x35,0x6A,0xD4,0xB3,0x7D,0xFA,0xEF, 
                           0xC5,0x91,0x39,0x72,0xE4,0xD3,0xBD,0x61,0xC2,0x9F,0x25,0x4A,0x94,0x33,0x66,0xCC, 
                           0x83,0x1D,0x3A,0x74,0xE8,0xCB,0x8D,0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x1B, 
                           0x36,0x6C,0xD8,0xAB,0x4D,0x9A,0x2F,0x5E,0xBC,0x63,0xC6,0x97,0x35,0x6A,0xD4,0xB3, 
                           0x7D,0xFA,0xEF,0xC5,0x91,0x39,0x72,0xE4,0xD3,0xBD,0x61,0xC2,0x9F,0x25,0x4A,0x94, 
                           0x33,0x66,0xCC,0x83,0x1D,0x3A,0x74,0xE8,0xCB,0x8D,0x01,0x02,0x04,0x08,0x10,0x20, 
                           0x40,0x80,0x1B,0x36,0x6C,0xD8,0xAB,0x4D,0x9A,0x2F,0x5E,0xBC,0x63,0xC6,0x97,0x35, 
                           0x6A,0xD4,0xB3,0x7D,0xFA,0xEF,0xC5,0x91,0x39,0x72,0xE4,0xD3,0xBD,0x61,0xC2,0x9F, 
                           0x25,0x4A,0x94,0x33,0x66,0xCC,0x83,0x1D,0x3A,0x74,0xE8,0xCB,0x8D,0x01,0x02,0x04, 
                           0x08,0x10,0x20,0x40,0x80,0x1B,0x36,0x6C,0xD8,0xAB,0x4D,0x9A,0x2F,0x5E,0xBC,0x63, 
                           0xC6,0x97,0x35,0x6A,0xD4,0xB3,0x7D,0xFA,0xEF,0xC5,0x91,0x39,0x72,0xE4,0xD3,0xBD, 
                           0x61,0xC2,0x9F,0x25,0x4A,0x94,0x33,0x66,0xCC,0x83,0x1D,0x3A,0x74,0xE8,0xCB,0x8D};

void KeyExpansionCore (unsigned char* in, unsigned char i) {

  //Rotate left:
  unsigned char t = in[0];
  in[0] = in[1];
  in[1] = in[2]; 
  in[2] = in[3]; 
  in[3] = t;

  //S-Box four bytes:
  in[0] = s_box[in[0]]; 
  in[1] = s_box[in[1]]; 
  in[2] = s_box[in[2]]; 
  in[3] = s_box[in[3]];

  //RCon
  in[0] ^= rcon[i]; 

};

void KeyExpansion(unsigned char* inputKey, unsigned char* expandedKeys) {

  //The first 16 bytes are the original key:
  for(int i=0; i<16; i++)
    expandedKeys[i] = inputKey[i];
  
  //Variables
  int bytesGenerated = 16; //We've generated 16 bytes out of 176 (11*16)
  int rconIteration = 1;   //RCon iteration begins at 1
  unsigned char temp[4];   //Temporary storage for core

  while (bytesGenerated < 176) {
    //Read last 4 bytes generated in the core
    for(int i=0; i<4; i++){
      temp[i] = expandedKeys[i + bytesGenerated - 4];
    }
    //Perform the core once for each 16 byte key:
    if(bytesGenerated % 16 == 0)
      KeyExpansionCore(temp, rconIteration++);
    //XOR temp with [bytesGenerated-16], and store in expandedKeys:
    for(unsigned char a=0; a<4; a++) {
      expandedKeys[bytesGenerated] = expandedKeys[bytesGenerated-16] ^ temp[a];
      bytesGenerated++;
    }
  }
  
};

void SubBytes(unsigned char* state) {

  /*
  Substitutes bytes from the state with the values from the S-Box. The S-Box is addressed by the value of the byte from the state.
  S-Box:
     | 0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
  ---|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|
  00 |63 7C 77 7B F2 6B 6F C5 30 01 67 2B FE D7 AB 76 
  10 |CA 82 C9 7D FA 59 47 F0 AD D4 A2 AF 9C A4 72 C0 
  20 |B7 FD 93 26 36 3F F7 CC 34 A5 E5 F1 71 D8 31 15 
  30 |04 C7 23 C3 18 96 05 9A 07 12 80 E2 EB 27 B2 75 
  40 |09 83 2C 1A 1B 6E 5A A0 52 3B D6 B3 29 E3 2F 84 
  50 |53 D1 00 ED 20 FC B1 5B 6A CB BE 39 4A 4C 58 CF 
  60 |D0 EF AA FB 43 4D 33 85 45 F9 02 7F 50 3C 9F A8 
  70 |51 A3 40 8F 92 9D 38 F5 BC B6 DA 21 10 FF F3 D2 
  80 |CD 0C 13 EC 5F 97 44 17 C4 A7 7E 3D 64 5D 19 73 
  90 |60 81 4F DC 22 2A 90 88 46 EE B8 14 DE 5E 0B DB 
  A0 |E0 32 3A 0A 49 06 24 5C C2 D3 AC 62 91 95 E4 79 
  B0 |E7 C8 37 6D 8D D5 4E A9 6C 56 F4 EA 65 7A AE 08 
  C0 |BA 78 25 2E 1C A6 B4 C6 E8 DD 74 1F 4B BD 8B 8A 
  D0 |70 3E B5 66 48 03 F6 0E 61 35 57 B9 86 C1 1D 9E 
  E0 |E1 F8 98 11 69 D9 8E 94 9B 1E 87 E9 CE 55 28 DF 
  F0 |8C A1 89 0D BF E6 42 68 41 99 2D 0F B0 54 BB 16

  example:
    Byte 48 is replaced by finding the value at the intersections of the row 40 and column 8.
    The new value for the byte is: 52.

  */

  for(int i=0; i<16; i++) {
    state[i] = s_box[state[i]];
  }
  

};

void ShiftRows(unsigned char* state) {
  
  /*
  shifts (rotates):
    - first row of the state 0 times
    - second row of the state 1 time
    - third row of the state 2 times
    - fourth row of the state 4 times

  state:                      new state:
  0  4  8  12                 0  4  8  12
  1  5  9  13    --------\    5  9  13 1
  2  6  10 14    --------/    10 14 2  6
  3  7  11 15                 15 3  7  11

  */

  unsigned char tmp[16];

  tmp[0] = state[0];
  tmp[1] = state[5];
  tmp[2] = state[10];
  tmp[3] = state[15];

  tmp[4] = state[4];
  tmp[5] = state[9];
  tmp[6] = state[14];
  tmp[7] = state[3];

  tmp[8] = state[8];
  tmp[9] = state[13];
  tmp[10] = state[2];
  tmp[11] = state[7];

  tmp[12] = state[12];
  tmp[13] = state[1];
  tmp[14] = state[6];
  tmp[15] = state[11];

  for (int i=0; i<16; i++) {
    state[i] = tmp[i];
  }

};

void MixColumns(unsigned char* state) {

  /*
  This function multiplies the state with a special matrix.
  The multiplications of elements inside the dot products are based on modulo2, and instead of creating a function that will do it, a lookup table is created.
  The additions inside the dot products are based on modulo2, so the XOR operator is used.

  old_state:           mult_matrix:           new_state: 
  s0  s4  s8  s12      2  3  1  1             (s0*2)xor(s1*3)xor(s2*1)xor(s3*1)  (s4*2)xor(s5*3)xor(s6*1)xor(s7*1)  (s8*2)xor(s9*3)xor(s10*1)xor(s11*1)  (s12*2)xor(s13*3)xor(s14*1)xor(s15*1)
  s1  s5  s9  s13  \/  1  2  3  1    ----\    (s0*1)xor(s1*2)xor(s2*3)xor(s3*1)  (s4*1)xor(s5*2)xor(s6*3)xor(s7*1)  (s8*1)xor(s9*2)xor(s10*3)xor(s11*1)  (s12*1)xor(s13*2)xor(s14*3)xor(s15*1)
  s2  s6  s10 s14  /\  1  1  2  3    ----/    (s0*1)xor(s1*1)xor(s2*2)xor(s3*3)  (s4*1)xor(s5*1)xor(s6*2)xor(s7*3)  (s8*1)xor(s9*1)xor(s10*2)xor(s11*3)  (s12*1)xor(s13*1)xor(s14*2)xor(s15*3)
  s3  s7  s11 s15      3  1  1  2             (s0*3)xor(s1*1)xor(s2*1)xor(s3*2)  (s4*3)xor(s5*1)xor(s6*1)xor(s7*2)  (s8*3)xor(s9*1)xor(s10*1)xor(s11*2)  (s12*3)xor(s13*1)xor(s14*1)xor(s15*2)
  */

  unsigned char tmp[256];

  tmp[0] = (unsigned char)(mul2[state[0]] ^ mul3[state[1]] ^ state[2] ^ state[3]);
  tmp[1] = (unsigned char)(state[0] ^ mul2[state[1]] ^ mul3[state[2]] ^ state[3]);
  tmp[2] = (unsigned char)(state[0] ^ state[1] ^ mul2[state[2]] ^ mul3[state[3]]);
  tmp[3] = (unsigned char)(mul3[state[0]] ^ state[1] ^ state[2] ^ mul2[state[3]]);
  
  tmp[4] = (unsigned char)(mul2[state[4]] ^ mul3[state[5]] ^ state[6] ^ state[7]);
  tmp[5] = (unsigned char)(state[4] ^ mul2[state[5]] ^ mul3[state[6]] ^ state[7]);
  tmp[6] = (unsigned char)(state[4] ^ state[5] ^ mul2[state[6]] ^ mul3[state[7]]);
  tmp[7] = (unsigned char)(mul3[state[4]] ^ state[5] ^ state[6] ^ mul2[state[7]]);
  
  tmp[8] = (unsigned char)(mul2[state[8]] ^ mul3[state[9]] ^ state[10] ^ state[11]);
  tmp[9] = (unsigned char)(state[8] ^ mul2[state[9]] ^ mul3[state[10]] ^ state[11]);
  tmp[10] = (unsigned char)(state[8] ^ state[9] ^ mul2[state[10]] ^ mul3[state[11]]);
  tmp[11] = (unsigned char)(mul3[state[8]] ^ state[9] ^ state[10] ^ mul2[state[11]]);
  
  tmp[12] = (unsigned char)(mul2[state[12]] ^ mul3[state[13]] ^ state[14] ^ state[15]);
  tmp[13] = (unsigned char)(state[12] ^ mul2[state[13]] ^ mul3[state[14]] ^ state[15]);
  tmp[14] = (unsigned char)(state[12] ^ state[13] ^ mul2[state[14]] ^ mul3[state[15]]);
  tmp[15] = (unsigned char)(mul3[state[12]] ^ state[13] ^ state[14] ^ mul2[state[15]]);

  for(int i=0; i<16; i++) {
    state[i] = tmp[i];
  }

};

void AddRoundKey(unsigned char* state, unsigned char* roundKey) {

  for(int i=0; i<16; i++) {
    state[i] ^= roundKey[i];
  }

};


void AES_Encrypt(unsigned char* message, unsigned char* key){

  unsigned char state[16];
  for(int i=0; i<16; i++)
    state[i] = message[i];

  int numberOfRounds = 9; // 9 + final round
  unsigned char expandedKey[176];

  //Expand the key
  KeyExpansion(key, expandedKey); 
  // Whitening/AddRoundKey
  AddRoundKey(state, key); 

  for (int i=0; i<numberOfRounds; i++){
    SubBytes(state);
    ShiftRows(state);
    MixColumns(state);
    AddRoundKey(state, expandedKey+(16*(i+1)));
  }

  //Final round
  SubBytes(state);
  ShiftRows(state);
  AddRoundKey(state, expandedKey+160);

  //Copy encrypted state to message:
  for(int i=0; i<16; i++) {
    message[i] = state[i];
  }

}

